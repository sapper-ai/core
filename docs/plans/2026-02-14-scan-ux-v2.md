# Scan CLI UX v2: Interactive Select + AI Deep Scan + HTML Report

## Context

v0.3.0에서 프로그레스 바, 범위 선택, 결과 테이블을 추가했다.
v2에서는 세 가지를 추가한다:

1. **화살표 키 인터랙티브 선택** — readline 숫자 입력을 `@inquirer/select` 로 교체
2. **AI 심층 탐지** — 기존 regex 1차 필터 후, 의심 파일만 OpenAI API로 2차 분석
3. **스캔 결과 저장 + 단일 HTML 리포트** — JSON 자동 저장 + `--report` 플래그로 브라우저에서 볼 수 있는 셀프 컨테인드 HTML 생성

## TODO

### 1. `@inquirer/select` 의존성 추가

- **파일**: `packages/sapper-ai/package.json`
- **변경**: `dependencies`에 `"@inquirer/select": "^4.0.0"` 추가
- **검증**: `pnpm install` 정상 완료

### 2. 인터랙티브 프롬프트 교체 (`cli.ts`)

- **파일**: `packages/sapper-ai/src/cli.ts`

#### 2-1. `promptScanScope()` 교체 (라인 106-126)

기존 `readline` 기반 코드를 `@inquirer/select`로 완전 교체:

```typescript
import select from '@inquirer/select'

async function promptScanScope(cwd: string): Promise<'shallow' | 'deep' | 'system'> {
  const answer = await select({
    message: 'Scan scope:',
    choices: [
      { name: `Current directory only     ${displayPath(cwd)}`, value: 'shallow' as const },
      { name: `Current + subdirectories   ${displayPath(join(cwd, '**'))}`, value: 'deep' as const },
      { name: 'AI system scan              ~/.claude, ~/.cursor, ~/.vscode ...', value: 'system' as const },
    ],
    default: 'deep',
  })
  return answer
}
```

- `readline` import 제거 (init wizard에서도 사용 중이면 유지)
- `console.log` 기반 메뉴 출력 코드 삭제

#### 2-2. `promptScanDepth()` 신규 함수 추가

```typescript
async function promptScanDepth(): Promise<boolean> {
  const answer = await select({
    message: 'Scan depth:',
    choices: [
      { name: 'Quick scan (rules only)      Fast regex pattern matching', value: false as const },
      { name: 'Deep scan (rules + AI)       AI-powered analysis (requires OPENAI_API_KEY)', value: true as const },
    ],
    default: false,
  })
  return answer
}
```

#### 2-3. `parseScanArgs()` 수정 (라인 66-98)

- **반환 타입 변경** (모든 새 플래그 포함):
  ```typescript
  function parseScanArgs(argv: string[]): {
    targets: string[]; fix: boolean; deep: boolean; system: boolean;
    ai: boolean; report: boolean; noSave: boolean;
  } | null
  ```
- 새 플래그 파싱 추가:
  ```typescript
  let ai = false
  let report = false
  let noSave = false

  if (arg === '--ai') { ai = true; continue }
  if (arg === '--report') { report = true; continue }
  if (arg === '--no-save') { noSave = true; continue }
  ```
- 반환 객체에 `ai, report, noSave` 포함

#### 2-4. `resolveScanOptions()` 수정 (라인 128-173)

- TTY + 플래그 없음 → `promptScanDepth()` 호출
- `--ai` 플래그 → `ai: true` 전달
- non-TTY → `ai: false` 기본값

#### 2-5. `ScanOptions` 수정

- **파일**: `packages/sapper-ai/src/scan.ts` (라인 21-27)
- `ai?: boolean` 필드 추가

#### 2-6. `printUsage()` 업데이트

```
sapper-ai scan --ai         Deep scan with AI analysis (requires OPENAI_API_KEY)
```

- **검증**: `pnpm --filter sapper-ai build` 성공

### 3. AI 심층 탐지 통합 (`scan.ts`)

- **파일**: `packages/sapper-ai/src/scan.ts`

#### 3-1. AI 설정 로직 추가

`runScan()` 함수 시작 부분에:

```typescript
const aiEnabled = options.ai === true
let llmConfig: LlmConfig | null = null

if (aiEnabled) {
  const apiKey = process.env.OPENAI_API_KEY
  if (!apiKey) {
    console.log('\n  Error: OPENAI_API_KEY environment variable is required for --ai mode.\n')
    return 1
  }
  llmConfig = { provider: 'openai', apiKey, model: 'gpt-4.1-mini' }
}
```

- `LlmConfig` 타입은 `@sapper-ai/types`에서 import

#### 3-2. 2단계 스캔 로직

기존 파일 순회 루프 (라인 393-413) 이후, 프로그레스 바 정리 (라인 415-417) 이후, 결과 출력 (라인 419) 이전에 AI 2차 분석 삽입:

**접근법**: 기존 `Scanner.scanTool()` 파이프라인을 재활용한다. AI 모드에서는 `createDetectors()`에 LLM config를 포함시켜 `DecisionEngine`이 자동으로 RulesDetector → LlmDetector 순으로 실행하도록 한다. 이렇게 하면 `AssessmentContext` 구성, `priorRisk` 주입 등을 직접 처리할 필요가 없다.

```typescript
// Phase 2: AI deep scan (only for suspicious files)
if (aiEnabled && llmConfig) {
  const suspiciousFindings = findings.filter(f => f.decision.risk >= 0.5)
  const maxAiFiles = 50  // cost cap: max 50 files per scan

  if (suspiciousFindings.length > 0) {
    const aiTargets = suspiciousFindings.slice(0, maxAiFiles)
    if (suspiciousFindings.length > maxAiFiles) {
      console.log(`  Note: AI scan limited to ${maxAiFiles} files (${suspiciousFindings.length} suspicious)`)
    }

    console.log()
    console.log(`  Phase 2/2: AI deep scan (${aiTargets.length} files)`)
    console.log()

    // create detectors with LLM enabled
    const aiDetectors = createDetectors({ policy, llm: llmConfig })

    for (let i = 0; i < aiTargets.length; i++) {
      const finding = aiTargets[i]!

      // render progress bar (same pattern as Phase 1)
      if (isTTY) {
        const bar = renderProgressBar(i + 1, aiTargets.length, progressWidth)
        const label = '  Analyzing: '
        const maxPath = Math.max(10, (process.stdout.columns ?? 80) - stripAnsi(bar).length - label.length)
        const scanning = `${label}${truncateToWidth(finding.filePath, maxPath)}`
        if (i === 0) {
          process.stdout.write(`${bar}\n${scanning}\n`)
        } else {
          process.stdout.write(`\x1b[2A\x1b[2K\r${bar}\n\x1b[2K\r${scanning}\n`)
        }
      }

      try {
        // re-scan with AI detectors using existing Scanner pipeline
        const raw = await readFileIfPresent(finding.filePath)
        if (!raw) continue
        const surface = normalizeSurfaceText(raw)
        const targetType = classifyTargetType(finding.filePath)
        const id = `${targetType}:${buildEntryName(finding.filePath)}`
        const aiDecision = await scanner.scanTool(id, surface, policy, aiDetectors)

        // merge: take higher risk, append AI reasons
        if (aiDecision.risk > finding.decision.risk) {
          finding.decision = { ...finding.decision, risk: aiDecision.risk, confidence: aiDecision.confidence }
        }
        finding.decision.reasons = [...finding.decision.reasons, ...aiDecision.reasons.filter(r => !finding.decision.reasons.includes(r))]
        finding.aiAnalysis = aiDecision.reasons.find(r => !r.startsWith('Detected pattern:')) ?? null
      } catch {
        // AI failure: keep rules-only result, continue scanning
      }
    }

    // clear AI progress bar
    if (isTTY && aiTargets.length > 0) {
      process.stdout.write('\x1b[2A\x1b[2K\r\x1b[1B\x1b[2K\r')
    }
  }
}
```

- `createDetectors`에 `llm` 옵션을 전달하면 `LlmDetector`가 파이프라인에 포함됨
- `DecisionEngine`이 `priorRisk` 주입을 자동 처리 (`withPriorRisk()`)
- AI 실패 시 `try/catch`로 감싸고 rules-only 결과 유지 (네트워크 에러, rate limit 등)
- **비용 제어**: `maxAiFiles = 50`으로 제한 (50파일 x ~$0.001 = ~$0.05)
- findings에 `aiAnalysis` 문자열 필드 추가

#### 3-3. 프로그레스 바 2단계 표시

AI 모드에서는 Phase 표시 추가:
- `Phase 1/2: Rules scan` → 기존 프로그레스 바
- `Phase 2/2: AI deep scan (N suspicious files)` → AI 분석 프로그레스 바

#### 3-4. `ScanFinding` 인터페이스 확장

```typescript
interface ScanFinding {
  filePath: string
  decision: Decision
  quarantinedId?: string
  aiAnalysis?: string  // NEW: LLM reasoning text
}
```

- **검증**: `pnpm --filter sapper-ai build && pnpm --filter sapper-ai test`

### 4. JSON 결과 저장 (`scan.ts`)

- **파일**: `packages/sapper-ai/src/scan.ts`

#### 4-1. `ScanResult` 인터페이스 정의

```typescript
interface ScanResult {
  version: '1.0'
  timestamp: string
  scope: string
  target: string
  ai: boolean
  summary: {
    totalFiles: number
    scannedFiles: number
    skippedFiles: number
    threats: number
  }
  findings: Array<{
    filePath: string
    risk: number
    confidence: number
    action: string
    patterns: string[]
    reasons: string[]
    snippet: string
    detectors: string[]
    aiAnalysis: string | null
  }>
}
```

#### 4-2. JSON 저장 로직

`runScan()` 결과 테이블 출력 직전에:

```typescript
const scanResult: ScanResult = buildScanResult(...)
const scanDir = join(homedir(), '.sapperai', 'scans')
await mkdir(scanDir, { recursive: true })
const filename = `${new Date().toISOString().replace(/[:.]/g, '-')}.json`
await writeFile(join(scanDir, filename), JSON.stringify(scanResult, null, 2))
```

- `--no-save` 플래그 추가 (parseScanArgs에서 파싱)
- 저장 경로를 터미널에 출력: `Saved to ~/.sapperai/scans/2026-02-14T...json`

#### 4-3. `ScanOptions` 확장

```typescript
export interface ScanOptions {
  targets?: string[]
  fix?: boolean
  deep?: boolean
  system?: boolean
  scopeLabel?: string
  ai?: boolean       // NEW
  report?: boolean   // NEW
  noSave?: boolean   // NEW
}
```

- **검증**: 스캔 후 `~/.sapperai/scans/` 디렉토리에 JSON 파일 생성 확인

### 5. HTML 리포트 생성기 (`report.ts`)

- **파일**: `packages/sapper-ai/src/report.ts` (신규)

#### 5-1. 전체 구조

```typescript
export function generateHtmlReport(result: ScanResult): string {
  return `<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SapperAI Scan Report - ${result.timestamp}</title>
  <style>${generateCss()}</style>
</head>
<body>
  ${renderHeader(result)}
  ${renderSummary(result)}
  ${renderMainContent(result)}
  <script>const SCAN_DATA = ${JSON.stringify(result)};</script>
  <script>${generateJs()}</script>
</body>
</html>`
}
```

#### 5-2. CSS 설계 (인라인)

**색상 팔레트 (CSS 변수)**:
```css
/* Dark mode (default) */
:root, [data-theme="dark"] {
  --bg-primary: #0a0a0a;
  --bg-secondary: #1a1a1a;
  --bg-tertiary: #2a2a2a;
  --border: #333333;
  --text-primary: #f5f5f5;
  --text-secondary: #a0a0a0;
  --text-muted: #666666;
  --accent: #00d9ff;
  --accent-glow: rgba(0, 217, 255, 0.15);
  --risk-critical: #ef4444;
  --risk-high: #f59e0b;
  --risk-low: #22c55e;
}

/* Light mode */
[data-theme="light"] {
  --bg-primary: #ffffff;
  --bg-secondary: #f9fafb;
  --bg-tertiary: #f3f4f6;
  --border: #e5e7eb;
  --text-primary: #0a0a0a;
  --text-secondary: #4b5563;
  --text-muted: #9ca3af;
  --accent: #0284c7;
  --accent-glow: rgba(2, 132, 199, 0.1);
}
```

**레이아웃**:
- Header: sticky, 72px, bg-secondary, border-bottom
- Summary: 4개 메트릭 카드 (grid 4col) + 위협 분포 바 차트
- Main: 2컬럼 (30% file tree + 70% detail panel), 독립 스크롤
- Mobile (<768px): 1컬럼, 탭 네비게이션

**타이포그래피**:
- 제목: system-ui (Outfit 폰트 임베드 생략, 파일 크기 절약)
- 본문: system-ui, -apple-system, sans-serif
- 코드: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace (시스템 폰트 활용)
- 메트릭: tabular-nums

#### 5-3. HTML 컴포넌트

**Header**:
```html
<header>
  <div class="logo">SapperAI Scan Report</div>
  <div class="meta">Scanned: {timestamp} | Scope: {scope}</div>
  <button id="theme-toggle">Dark/Light</button>
</header>
```

**Summary Cards**:
```html
<section class="summary">
  <div class="metric-card">
    <span class="label">Total Files</span>
    <span class="value">21,581</span>
  </div>
  <div class="metric-card">
    <span class="label">Threats</span>
    <span class="value danger">108</span>
  </div>
  <div class="metric-card">
    <span class="label">Max Risk</span>
    <span class="value">0.95</span>
  </div>
  <div class="metric-card">
    <span class="label">AI Scan</span>
    <span class="value">Enabled</span>
  </div>
</section>
```

**Risk Distribution Bar Chart**:
- Critical (>=0.8): 빨강 바
- High (>=0.5): 노랑 바
- Clean (0): 초록 바
- 클릭 시 해당 레벨 파일만 필터링

**File Tree (왼쪽)**:
```html
<aside class="file-tree">
  <input type="text" placeholder="Search files..." id="tree-search">
  <label><input type="checkbox" id="threats-only" checked> Threats only (108)</label>
  <div id="tree" role="tree">
    <!-- JS로 렌더링 -->
  </div>
</aside>
```

- 폴더: chevron 아이콘 + 이름 + 하위 위협 수
- 파일: risk 컬러 도트 (빨강/노랑/초록) + 이름 + risk 점수
- 호버: bg-tertiary
- 선택: bg-accent-glow, border-left 3px accent

**Detail Panel (오른쪽)**:
```html
<main class="detail-panel" id="detail">
  <!-- 초기: "Select a file to view details" -->
  <!-- 파일 선택 시: -->
  <div class="file-header">
    <div class="file-path">{경로}</div>
    <div class="file-name">{파일명}</div>
    <div class="metrics">
      <span>Risk: <span class="risk-bar">{0.95}</span></span>
      <span>Confidence: 90%</span>
      <span class="badge block">BLOCK</span>
    </div>
  </div>
  <div class="patterns">
    <h3>Detected Patterns</h3>
    <ul><li>secret exfiltration</li></ul>
  </div>
  <div class="snippet">
    <h3>Code Snippet</h3>
    <pre><code>{매칭된 텍스트, 패턴 부분 하이라이트}</code></pre>
  </div>
  <div class="detectors">
    <span class="badge">Rules</span>
    <span class="badge">LLM</span>
  </div>
  <div class="ai-analysis">
    <h3>AI Analysis</h3>
    <p>{LLM reasoning}</p>
  </div>
</main>
```

#### 5-4. JavaScript (인라인, 바닐라 JS)

**기능 목록**:
1. `buildFileTree(findings)` — findings 배열을 디렉토리 트리 구조로 변환, DOM 렌더링
2. `handleFileClick(filePath)` — Detail Panel 업데이트
3. `handleSearch(query)` — 파일명 필터링 (debounce 300ms)
4. `handleThreatsOnlyToggle()` — 위협만/전체 토글
5. `handleThemeToggle()` — data-theme 속성 전환, localStorage 저장
6. `handleChartBarClick(riskLevel)` — 분포 차트 바 클릭 시 해당 레벨 필터링
7. 키보드 네비게이션: 화살표 키로 트리 이동, Enter로 선택

**파일 트리 빌드 알고리즘**:
```
findings → Map<dirPath, { files, subdirs, maxRisk, threatCount }>
→ 재귀 렌더링 (DFS)
→ 폴더: <details> 태그로 접기/펼치기
→ 파일: <button> 태그, click 이벤트
```

#### 5-5. 반응형 & 인쇄

**브레이크포인트**:
- Desktop (>1024px): 2컬럼 30%/70%
- Tablet (768-1024px): 2컬럼 40%/60%
- Mobile (<768px): 1컬럼 스택

**Print CSS**:
- 파일 트리 전체 펼침
- 위협 파일 상세만 출력
- 컬러 보존 (`print-color-adjust: exact`)

### 6. CLI에서 리포트 연동

- **파일**: `packages/sapper-ai/src/cli.ts`

#### 6-1. `--report` 플래그 추가

`parseScanArgs()`에 `--report` 파싱:
```typescript
if (arg === '--report') {
  report = true
  continue
}
```

#### 6-2. `scan.ts`에서 리포트 생성 호출

`runScan()` 마지막에:
```typescript
if (options.report) {
  const { generateHtmlReport } = await import('./report')
  const html = generateHtmlReport(scanResult)
  const reportPath = join(process.cwd(), 'sapper-report.html')
  await writeFile(reportPath, html)
  console.log(`  Report saved to ${reportPath}`)

  // auto-open in browser (cross-platform)
  const { exec } = await import('node:child_process')
  const openCmd = process.platform === 'darwin' ? 'open'
    : process.platform === 'win32' ? 'start'
    : 'xdg-open'
  exec(`${openCmd} "${reportPath}"`)

}
```

#### 6-3. `printUsage()` 업데이트

```
sapper-ai scan --report      Generate HTML report and open in browser
sapper-ai scan --no-save     Skip saving scan results to ~/.sapperai/scans/
```

### 7. 테스트

- **파일**: `packages/sapper-ai/src/__tests__/scan.test.ts`

#### 7-1. 기존 테스트 호환성 확인

- 모든 기존 7개 테스트가 통과하는지 확인
- `ScanOptions` 변경이 기존 테스트 호출에 영향 없는지 확인

#### 7-2. AI 스캔 테스트 (필수)

- LlmDetector mock으로 AI 2차 분석 흐름 테스트
- API 키 없이 `--ai` 사용 시 exit code 1 확인
- AI API 실패 시 rules-only 결과로 폴백 확인

#### 7-3. JSON 저장 테스트

- 스캔 후 `~/.sapperai/scans/` 에 JSON 파일 생성 확인
- `--no-save` 시 파일 미생성 확인

#### 7-4. HTML 리포트 테스트

- **파일**: `packages/sapper-ai/src/__tests__/report.test.ts` (신규)
- `generateHtmlReport(mockResult)` 호출 시:
  - 반환값이 `<!DOCTYPE html>`로 시작
  - `SCAN_DATA` 스크립트 태그 포함
  - findings 수만큼 트리 노드 데이터 포함

#### 7-5. `cli.test.ts` 호환성 확인

- **파일**: `packages/sapper-ai/src/__tests__/cli.test.ts`
- 기존 readline mock은 `init` 테스트 전용 → `@inquirer/select`와 충돌 없음
- `scan` 테스트가 추가되면 `@inquirer/select`를 `vi.doMock('@inquirer/select', ...)`로 mock
- 기존 5개 CLI 테스트 모두 통과 확인

## 수정 파일 목록

| 파일 | 변경 유형 |
|------|-----------|
| `packages/sapper-ai/package.json` | 수정 — `@inquirer/select` 의존성 추가 |
| `packages/sapper-ai/src/cli.ts` | 수정 — inquirer 교체, `--ai`/`--report`/`--no-save` 플래그 |
| `packages/sapper-ai/src/scan.ts` | 수정 — AI 2차 분석, JSON 저장, ScanOptions 확장 |
| `packages/sapper-ai/src/report.ts` | 신규 — HTML 리포트 생성기 |
| `packages/sapper-ai/src/__tests__/report.test.ts` | 신규 — 리포트 테스트 |
| `packages/sapper-ai/src/__tests__/cli.test.ts` | 수정 — scan 관련 테스트 추가 시 inquirer mock |

## Verification

```bash
# 1. 빌드
pnpm --filter sapper-ai build

# 2. 테스트
pnpm --filter sapper-ai test

# 3. 인터랙티브 모드 (화살표 키 확인)
npx sapper-ai scan

# 4. AI 딥 스캔
OPENAI_API_KEY=sk-... npx sapper-ai scan --ai

# 5. HTML 리포트 생성
npx sapper-ai scan --report

# 6. JSON 저장 확인
ls ~/.sapperai/scans/

# 7. non-TTY
echo "" | npx sapper-ai scan --deep
```
